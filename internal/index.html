<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Kit</title>

    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.min.js"></script>

    <style id="css">
        body {
            font: 300 14px 'Helvetica Neue', Helvetica;
        }

        .node rect {
            stroke: #999;
            fill: #fff;
            stroke-width: 1.5px;
        }

        .edgePath path {
            stroke: #333;
            stroke-width: 1.5px;
        }

        .name {
            font-weight: bold;
        }

        .starting> rect {
            fill: aqua;
        }

        .running > rect {
            fill: mediumspringgreen;
        }

        .failed > rect {
            fill: red;
        }

        .failed div {
            color: white;
        }

    </style>
</head>
<body>

<svg width=100% height=100%>
    <g/>
</svg>


<script id="js">
    // Create a new directed graph
    const g = new dagreD3.graphlib.Graph()
        .setGraph({
            rankdir: "LR",
        })
        .setDefaultEdgeLabel(function () {
            return {};
        });

    const renderNode = (node) => {

        console.log(node.name)

        const phase = node.phase;
        const symbol = phase === 'pending' || phase === 'waiting' ? '⏸' :
            phase === 'starting' || phase === 'running' ? '▶' :
                phase === 'succeeded' ? '✔' :
                    phase === 'failed' ? '⛒' : '';

        g.setNode(node.name, {
            labelType: "html",
            title: node.message,
            label: `<div ><div class="name">${node.name}</div><div>${symbol} ${node.phase}: ${node.message}</div></div>`,
            class: node.phase,
            rx: 5,
            ry: 5,
        });
    }

    // get the graph from the server at /dag
    fetch('/dag')
        .then(response => response.json())
        .then(data => {
            // data.nodes is a map of node names to node objects
            Object.values(data.nodes).forEach(node => {
                renderNode(node);
            });
            // data.children is a map from node name to children name
            Object.keys(data.children).forEach(parent => {
                data.children[parent].forEach(child => {
                    g.setEdge(parent, child);
                });
            });

            // Create the renderer
            const render = new dagreD3.render();

            // Set up an SVG group so that we can translate the final graph.
            const svg = d3.select("svg"),
                svgGroup = svg.append("g");

            // Run the renderer. This is what draws the final graph.
            render(d3.select("svg g"), g);

            // Center the graph
            const xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
            svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
            svg.attr("height", g.graph().height + 40);

            // start the event stream
            const eventSource = new EventSource('/events');

            eventSource.onmessage = (event) => {
                const node = JSON.parse(event.data);
                renderNode(node);
                render(d3.select("svg g"), g);
            }
        });
</script>

</body>
</html>